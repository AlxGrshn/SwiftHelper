//
//  SwiftData.swift
//  SwiftHelper
//
//  Created by Roman on 25.10.2022.
//

struct Topic {
    let title: String
    let description: String
    
    static func getTopics() -> [Topic] {
        [
            Topic(
                title: "Константы и переменные",
                description:
"""
Константы - неизменяемые свойства.
Переменные - изменяемые свойства.

Используйте let для создания констант и var для объявления переменных.
Значение константы не обязательно должно быть известно на момент компиляции, но оно должно присваиваться строго один раз.
Это значит, что вы можете использовать константу для обозначения значения, определяемого единожды, но используемого во многих местах.

Константа или переменная должны иметь те же типы данных, которые вы хотите им присвоить. Хотя, вы не должны всегда явно объявлять тип.
Когда вы присваиваете значение при создании константы или переменной, компилятор логически предугадывает его тип.

Если присвоенное значение не дает достаточной информации (или когда значение еще не присвоено), укажите тип, написав его после названия, разделенной с помощью двоеточия.
"""
            ),
            Topic(
                title: "Типы данных",
                description:
"""
Тип данных — это множество всех возможных значений, а также операций над ними.

Например, если у параметра числовой тип данных, то ему может быть присвоено числовое значение, с которым можно проводить математические операции (сложение, вычитание, деление, умножение и т. д.).

Воспринимайте типы данных как абстракции, шаблоны, на основе которых создаются конкретные значения. Например, на основе типа данных «целое число» можно создать значения 2, 17, 36. Сам по себе тип «целое число» лишь выделяет диа- пазон возможных значений, но не несет никакой конкретики, никакой точной величины.
"""
            ),
            Topic(
                title: "Базовые операторы",
                description:
"""
Унарные операторы -  применяются одной величине (-3, !а)
Бинарные операторы - применяются к двум величинам (2+3)
Тернарные операторы - применяются к трем величинам. В SWIFT один тернарный условный оператор (a ? b : c)

Операнды - величины к которым применяются операторы ( 1 и 2 - операнды , если 1 + 2)
Операторы - специальные символы , при помощи которых можно производить, как арифметические действия, так и операции сравнения , изменения или проверки

Операторы делятся на:
- Арифметические операторы :
    - + сложение
    - - вычитание
    - * умножение
    - / деление
    - % остаток от деления

- Операторы присваивания:
    - a = b - инициализирует(изменяет) значение переменной a на значение переменной b

- Операторы сравнения
    - сравнивают меж собой два значения (a == b)
    - не равно a != b
    - больше, меньше >, <, >=, <=

- Операторы диапазона
    - оператор замкнутого диапазона (закрытого) a...b - диапазон значенией от a до  b включая сами значения
    - a..<, a..>, a...

- Логические операторы
    - (!) логическое значение НЕ
    - (&&) логическая И
    - (||) логическое ИЛИ (в случае если один из операндов имеет true)
"""
            ),
            Topic(
                title: "Операторы ветвлений",
                description:
"""
Цикл For-in
Цикл for-in используется для итерации по коллекциям элементов, таких как диапазоны чисел, элементы массива или символы в строке.

Цикл While
Цикл while выполняет набор инструкций до тех пор, пока его условие не станет false. Этот вид циклов лучше всего использовать в тех случаях, когда количество итераций до первого входа в цикл неизвестно. Swift предлагает два вида циклов while:
-   while - вычисляет условие выполнения в начале каждой итерации цикла.
Цикл while начинается с вычисления условия. Если условие истинно, то инструкции в теле цикла будут выполняться до тех пор, пока оно не станет ложным.

Цикл repeat-while
-   repeat-while - вычисляет условие выполнения в конце каждой итерации цикла.
Другой вариант цикла while, известный как цикл repeat-while, выполняет одну итерацию до того, как происходит проверка условия. Затем цикл продолжает повторяться до тех пор, пока условие не станет false.

Инструкция if
В самой простой своей форме инструкция if имеет всего одно условие if.
Эта инструкция выполняет установленные инструкции только в случае, когда условие true.
Инструкция if может предусматривать еще один дополнительный набор инструкций в ветке известной как оговорка else, которая нужна в случае, если условие false.

Инструкция switch
Инструкция switch подразумевает наличие какого-то значения, которое сравнивается с несколькими возможными шаблонами.
После того как значение совпало с каким-либо шаблоном, выполняется код, соответствующий ответвлению этого шаблона, и больше сравнений уже не происходит.
Switch представляет собой альтернативу инструкции if, отвечающей нескольким потенциальным значениям.
"""
            ),
            Topic(
                title: "Типы коллекций",
                description:
"""
Swift обеспечивает три основных типа коллекций - это Массивы, Множества и Словари для хранения коллекций значений.

Массивы - это упорядоченные коллекции значений.
Множества - это неупорядоченные коллекции уникальных значений.
Словари - это неупорядоченные коллекции, хранящие пары "ключ-значение".

Массивы
Массивы хранят много значений одинакового типа в упорядоченном списке. Одно и то же значение в массиве может появиться несколько раз, в разных позициях.

Множества
Множество хранит различные значения одного типа в виде коллекции в неупорядоченной форме. Вы можете использовать множества как альтернативы массиву, когда порядок для вас значения не имеет или когда вам нужно быть уверенным в том, что значения внутри коллекции не повторяются.

Словари
Словарь представляет собой контейнер, который хранит несколько значений одного и того же типа.
Каждое значение связано с уникальным _ключом_, который выступает в качестве идентификатора этого значения внутри словаря.
В отличие от элементов в массиве, элементы в словаре не имеют определенного порядка.
Используйте словарь, когда вам нужно искать значения на основе их идентификатора, так
же как в реальном мире словарь используется для поиска определения конкретного слова.
"""
            ),
            Topic(
                title: "Функции",
                description:
"""
Функции – это самостоятельные фрагменты кода, решающие определенную задачу.
Каждой функции присваивается уникальное имя, по которому ее можно идентифицировать и "вызвать" в нужный момент.

Каждая функция в Swift имеет тип, описывающий тип параметров функции и тип возвращаемого значения.
Тип функции можно использовать аналогично любым другим типам в Swift, т. е. одна функция может быть параметром другой функции либо ее результирующим значением.
Функции также могут вкладываться друг в друга, что позволяет инкапсулировать определенный алгоритм внутри локального контекста.

Объявление и вызов функций
При объявлении функции можно задать одно или несколько именованных типизированных значений, которые будут ее входными данными (или _параметрами_), а также тип значения, которое функция будет возвращать в качестве результата (или _возвращаемый тип_).

У каждой функции должно быть _имя_, которое отражает решаемую задачу.
Чтобы воспользоваться функцией, ее нужно "вызвать", указав имя и входные значения (_аргументы_), соответствующие типам параметров этой функции.
Аргументы функции всегда должны идти в том же порядке, в каком они были указаны при объявлении функции.
"""
            ),
            Topic(
                title: "Замыкания",
                description:
"""
Замыкания - это самодостаточные блоки с определенным функционалом, которые могут быть переданы и использованы в вашем коде.
Замыкания в Swift похожи на блоки в C и Objective-C, и лямбды в других языках программирования.

Замыкания могут захватывать и хранить ссылки на любые константы и переменные из контекста, в котором они объявлены.
Эта процедура известна как заключение этих констант и переменных, отсюда и название "замыкание".
Swift выполняет всю работу с управлением памятью при захвате за вас.

Глобальные и вложенные функции являются частным случаем замыканий.

Замыкания принимают одну из трех форм:
-   Глобальные функции являются замыканиями, у которых есть имя и которые не захватывают никакие значения.
-   Вложенные функции являются замыканиями, у которых есть имя и которые могут захватывать значения из включающей их функции.
-   Замыкающие выражения являются безымянными замыканиями, написанные в облегченном синтаксисе, которые могут захватывать значения из их окружающего контекста.
"""
            ),
            Topic(title: "Инструкция guard", description:
"""
Инструкция guard используется для перевода контроля программы из области видимости, если одно или несколько условий не выполняются.

Выглядит следующим образом:

guard условие else {
выражения для исполнения, если условие false
}

Значение любого состояния в инструкции guard должно иметь тип, соответствующий протоколу Boolean. Условие может быть также объявлением опциональной привязки, см. Привязка опционалов.

Любые константы или переменные, которым присвоено значение из объявления привязки опционалов в условии инструкции guard, могут быть использованы для остальной части области видимости инструкции guard.

Требуется условие else инструкции guard, и оно должно либо вызывать функцию, отмеченную атрибутом noreturn или передать программное управление за пределы области видимости инструкции guard, используя одну из следующих инструкций:

    return
    break
    continue
    throw
"""
            ),
            Topic(title: "Опциональные типы данных", description:
"""
Опциональные типы используются в тех случаях, когда значение может отсутствовать. Опциональный тип подразумевает, что возможны два варианта: или значение есть, и его можно извлечь из опционала, либо его вообще нет.

Приведем пример, который покажет, как опционалы могут справиться с отсутствием значения. У типа Int в Swift есть инициализатор, который пытается преобразовать значение String в значение типа Int. Тем не менее, не каждая строка может быть преобразована в целое число. Строка "123" может быть преобразована в числовое значение 123, но строка "hello, world" не имеет очевидного числового значения для преобразования.

В приведенном ниже примере используется метод Int() для попытки преобразовать String в Int:

    let possibleNumber = "123"
    let convertedNumber = Int(possibleNumber)
    // для convertedNumber выведен тип "Int?", или "опциональный Int"

Поскольку метод Int() может иметь недопустимый аргумент, он возвращает опциональный Int, вместо Int. Опциональный Int записывается как Int?, а не Int. Знак вопроса означает, что содержащееся в ней значение является опциональным, что означает, что он может содержать некое Int значение, или он может вообще не содержать никакого значения. (Он не может содержать ничего другого, например, Bool значение или значение String. Он либо Int, либо вообще ничто)
"""                 ),
            Topic(
                title: "Классы",
                description:
"""
Классы и структуры являются универсальными и гибкими конструкциями, которые станут строительными блоками для кода вашей программы.
Для добавления функциональности в классах и структурах можно объявить свойства и методы, применив тот же синтаксис, как и при объявлении констант, переменных и функций.

Экземпляр класса традиционно называют объектом.
Тем не менее, классы и структуры в Swift гораздо ближе по функциональности.
В связи с этим, употребляется более общий термин - экземпляр.

В отличие от типа значений, ссылочный тип не копируется, когда его присваивают переменной или константе, или когда его передают функции.
Вместо копирования используется ссылка на существующий экземпляр.

Классы имеют дополнительные возможности, которых нет у структур:
-   Наследование позволяет одному классу наследовать характеристики другого
-   Приведение типов позволяет проверить и интерпретировать тип экземпляра класса в процессе выполнения
-   Деинициализаторы позволяют экземпляру класса освободить любые ресурсы, которые он использовал
-   Подсчет ссылок допускает более чем одну ссылку на экземпляр класса.
"""
            ),
            Topic(title: "Структуры", description:
"""
Структуры, или structs, являются одним из именованных типов в Swift, которые позволяют инкапсулировать связанные свойства и поведение. Вы можете определить его, дать ему имя, а затем использовать его в коде.
Экземпляр структуры это объект, а не ссылка на объект. Свойства структуры указываются через var. Имеют встроенные инициализатор, свойства автоматические попадают в инициализатор. Структуры не могут наследоваться от другого класса или структуры.

Классы и структуры в Swift имеют много общего. И в классах и в структурах можно:

    - Объявлять свойства для хранения значений
    - Объявлять методы, чтобы обеспечить функциональность
    - Объявлять индексы, чтобы обеспечить доступ к их значениям, через синтаксис индексов
    - Объявлять инициализаторы, чтобы установить их первоначальное состояние
    - Они оба могут быть расширены, чтобы расширить их функционал за пределами стандартной реализации
    - Они оба могут соответствовать протоколам, для обеспечения стандартной функциональности определенного типа
"""
                 ),
            Topic(title: "Перечисления", description:
"""
Перечисления определяют общий тип для группы ассоциативных значений и позволяют работать с этими значениями в типобезопасном режиме в вашем коде.

Если вы знакомы с C, то вы знаете, что перечисления в C присваивают соответствующие имена набору целочисленных значений. Перечисления в Swift более гибкий инструмент и не должны предоставлять значения для каждого члена перечисления. Если значение (известное как “сырое” значение) предоставляется каждому члену перечисления, то это значение может быть строкой, символом или целочисленным значением, числом с плавающей точкой.

Кроме того, членам перечисления можно задать соответствующие значения любого типа, которые должны быть сохранены вместе с каждым кейсом перечисления. Вы можете определить общий набор соответствующих значений как часть одного перечисления, каждый из которых будет иметь разные наборы значений ассоциативных типов связанных с ними.

Перечисления в Swift - типы “первого класса”. Они обладают особенностями, которые обычно поддерживаются классами, например, вычисляемые свойства, для предоставления дополнительной информации о текущем значении перечисления, методы экземпляра для дополнительной функциональности, относящейся к значениям, которые предоставляет перечисление.

Перечисления так же могут объявлять инициализаторы для предоставления начального значения элементам. Они так же могут быть расширены для наращивания своей функциональности над её начальной реализацией. Могут соответствовать протоколам для обеспечения стандартной функциональности.

"""
                 ),
            Topic(title: "Наследование", description:
"""
Класс может наследовать методы, свойства и другие характеристики другого класса. Когда один класс наследует у другого класса, то наследующий класс называется подклассом, класс у которого наследуют - суперклассом. Наследование - фундаментальное поведение, которое отделяет классы от других типов Swift.

Классы в Swift могут вызывать или получать доступ к методам, свойствам, индексам, принадлежащим их суперклассам и могут предоставлять свои собственные переписанные версии этих методов, свойств, индексов для усовершенствования или изменения их поведения.

Классы так же могут добавлять наблюдателей свойств к наследованным свойствам для того, чтобы быть в курсе, когда происходит смена значения свойства. Наблюдатели свойств могут быть добавлены для любого свойства, несмотря на то были ли они изначально определены как хранимые свойства или вычисляемые.

Любой класс, который ничего не наследует из другого класса, называется базовым классом.
Заметка

Классы в Swift ничего не наследуют от универсального базового класса. Классы, у которых не указан супер класс (родительский класс), называются базовыми, которые вы можете использовать для строительства других классов.
"""
                 ),
            Topic(title: "Протоколы", description:
"""
Протокол определяет образец методов, свойств или другие требования, которые соответствуют определенному конкретному заданию или какой-то функциональности. Протокол фактически не предоставляет реализацию для любого из этих требований, он только описывает как реализация должна выглядеть. Протокол может быть принят классом, структурой или перечислением для обеспечения фактической реализации этих требований. Любой тип, который удовлетворяет требованиям протокола, имеет указание соответствовать этому протоколу или другими словами реализовать данный протокол.

В дополнение к определенным требованиям, которые должны быть реализованы подписанными под протокол типами, вы можете расширить протокол, чтобы реализовать некоторые из этих требований или для того, чтобы реализовать дополнительную функциональность, которую смогут использовать подписанные под протокол типы.

Определение протокола очень похоже на то, как вы определяете классы, структуры и перечисления:

protocol SomeProtocol {
    // определение протокола…
}

Пользовательские типы утверждают, что они принимают протокол, когда они помещают имя протокола после имени типа и разделяются с этим именем двоеточием, то есть указывают эти протоколы как часть их определения. После двоеточия вы можете указывать множество протоколов, перечисляя их имена через запятую:

struct SomeStructure: FirstProtocol, AnotherProtocol {
    // определение структуры…
}

Если у класса есть суперкласс, то вписывайте имя суперкласса до списка протоколов, которые он принимает, также разделите имя суперкласса и имя протокола запятой:

class SomeClass: SomeSuperclass, FirstProtocol, AnotherProtocol {
    // определение класса…
}
"""
                 ),
            Topic(title: "Расширения", description:
"""
Расширения добавляют новую функциональность существующему типу класса, структуры или перечисления. Это включает в себя возможность расширять типы, к исходным кодам которых у вас нет доступа (известно как ретроактивное моделирование). Расширения очень похожи на категории из Objective-C. (В отличии от категорий из Objective-C, расширения в Swift не имеют имен.)

Расширения в Swift могут:

    - Добавлять вычисляемые свойства и вычисляемые свойства типа
    - Определять методы экземпляра и методы типа
    - Предоставлять новые инициализаторы
    - Определять сабскрипты (индексы)
    - Определять новые вложенные типы
    - Обеспечить соответствие существующего типа протоколу

В Swift вы можете даже расширить протокол, предоставив реализацию его требованиям или добавить дополнительные функциональные возможности, преимущества которых могут быть использованы подписанным под протокол типом.

Расширения могут добавлять новую функциональность типу, но они не могут переписать существующую функциональность.

Расширение объявляется с помощью ключевого слова extension:

extension SomeType {
    // описываем новую функциональность для типа SomeType
}

Расширение может расширить существующий тип для того, чтобы он соответствовал одному или более протоколам. Там где это имеет место, имена протоколов записываются точно так же, как и в случае с классами или структурами:

extension SomeType: SomeProtocol, AnotherProtocol {
    // реализация требования протокола тут
}

Описание добавления соответствия протоколу таким образом описано в разделе Добавление реализации протокола через расширение.

Расширения могут быть использованы для расширения существующего универсального типа, что описано в Расширяем универсальный тип. Так же вы можете расширить универсальный тип, добавляя функциональность зависящую от условия, что описано в Оговорка where.
"""
                 ),
        ]
    }
}


